// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 9.1.0
// Project name: SquareLine_Project

#include "Scr.h"
#include "ui/ui.h"   // for changeScreen(), etc.
#include "alert.h"
#include "utils/util.h"
#include "utils/touch_lib.h"

// --- small helpers ---
static inline const char* safeTxt(const char* s){ return s ? s : ""; }
static inline bool hasTxt(const char* s){ return s && *s; }

// User data we attach to each msgbox button
struct MsgBtnData {
    Scr* self;
    void (*cb)();
};

Scr::Scr(lv_image_dsc_t navbarImage, bool showPressures)
{
    this->navbarImage   = navbarImage;
    this->showPressures = showPressures;
}

void Scr::init()
{
    this->scr = lv_obj_create(NULL);
    lv_obj_remove_flag(this->scr, LV_OBJ_FLAG_SCROLLABLE);

    // background
    this->rect_bg = lv_obj_create(this->scr);
    lv_obj_remove_style_all(this->rect_bg);
    lv_obj_set_size(this->rect_bg, 240, 320);
    lv_obj_set_align(this->rect_bg, LV_ALIGN_TOP_MID);
    lv_obj_set_style_border_width(this->rect_bg, 0, LV_PART_MAIN);
    lv_obj_set_style_bg_color(this->rect_bg, lv_color_hex(GENERIC_GREY_DARK), LV_PART_MAIN);
    lv_obj_remove_flag(this->rect_bg, (lv_obj_flag_t)(LV_OBJ_FLAG_CLICKABLE | LV_OBJ_FLAG_SCROLLABLE));
    lv_obj_set_style_bg_opa(this->rect_bg, 255, LV_PART_MAIN);

    // navbar image
    this->icon_navbar = lv_image_create(this->scr);
    lv_image_set_src(this->icon_navbar, &this->navbarImage);
    lv_obj_set_align(this->icon_navbar, LV_ALIGN_BOTTOM_MID);

    this->alert = new Alert(this);

    if (this->showPressures)
    {
        const int xPadding = 72;
        setupPressureLabel(this->scr, &this->ui_lblPressureFrontDriver,     -xPadding, 10, LV_ALIGN_TOP_MID, "0");
        setupPressureLabel(this->scr, &this->ui_lblPressureRearDriver,      -xPadding, 40, LV_ALIGN_TOP_MID, "0");
        setupPressureLabel(this->scr, &this->ui_lblPressureFrontPassenger,   xPadding, 10, LV_ALIGN_TOP_MID, "0");
        setupPressureLabel(this->scr, &this->ui_lblPressureRearPassenger,    xPadding, 40, LV_ALIGN_TOP_MID, "0");
        setupPressureLabel(this->scr, &this->ui_lblPressureTank,                  0, 10, LV_ALIGN_TOP_MID, "0");
    }
}

void Scr::runTouchInput(SimplePoint pos, bool down)
{
    if (down)
    {
        if (isKeyboardHidden())
        {
            if (!isMsgBoxDisplayed())
            {
                if (sr_contains(navbarbtn_home, pos))     { changeScreen(SCREEN_HOME); }
                if (sr_contains(navbarbtn_presets, pos))  { changeScreen(SCREEN_PRESETS); }
                if (sr_contains(navbarbtn_settings, pos)) { changeScreen(SCREEN_SETTINGS); }
            }
        }
    }
    else
    {
        // With non-blocking msgbox, nothing special to do on release.
    }
}

void Scr::showMsgBox(const char* title,
                     const char* body,
                     const char* btnLeft,
                     const char* btnRight,
                     void (*onLeft)(),
                     void (*onRight)(),
                     bool modal)
{
    // Remove any previous dialog/backdrop
    if (msgbox)          { lv_obj_del(msgbox);          msgbox = nullptr; }
    if (msgbox_backdrop) { lv_obj_del(msgbox_backdrop); msgbox_backdrop = nullptr; }

    lv_obj_t* parent = this->scr;

    if (modal) {
        msgbox_backdrop = lv_obj_create(parent);
        lv_obj_remove_style_all(msgbox_backdrop);
        lv_obj_set_size(msgbox_backdrop, lv_pct(100), lv_pct(100));
        lv_obj_set_style_bg_opa(msgbox_backdrop, LV_OPA_50, 0);
        parent = msgbox_backdrop;
    }

    // Create msgbox container
    msgbox = lv_msgbox_create(parent);
    lv_obj_center(msgbox);
    lv_obj_set_style_max_width(msgbox, lv_pct(90), 0);

    // Title & body (safe to pass empty strings)
    if (hasTxt(title)) lv_msgbox_add_title(msgbox, safeTxt(title));
    if (hasTxt(body))  lv_msgbox_add_text (msgbox, safeTxt(body));

    // Footer buttons: create only when non-empty
    if (hasTxt(btnLeft)) {
        lv_obj_t* b = lv_msgbox_add_footer_button(msgbox, btnLeft);
        lv_obj_set_flex_grow(b, 1);
        // attach callback
        auto* data = new MsgBtnData{ this, onLeft };
        lv_obj_add_event_cb(b, [](lv_event_t* e){
            auto* d = (MsgBtnData*) lv_event_get_user_data(e);
            if (d && d->cb) d->cb();
            if (d && d->self && d->self->msgbox) lv_msgbox_close_async(d->self->msgbox);
            delete d;
        }, LV_EVENT_CLICKED, (void*)data);
    }

    if (hasTxt(btnRight)) {
        lv_obj_t* b = lv_msgbox_add_footer_button(msgbox, btnRight);
        lv_obj_set_flex_grow(b, 1);
        auto* data = new MsgBtnData{ this, onRight };
        lv_obj_add_event_cb(b, [](lv_event_t* e){
            auto* d = (MsgBtnData*) lv_event_get_user_data(e);
            if (d && d->cb) d->cb();
            if (d && d->self && d->self->msgbox) lv_msgbox_close_async(d->self->msgbox);
            delete d;
        }, LV_EVENT_CLICKED, (void*)data);
    }

    // Style tweaks (optional)
    lv_obj_set_style_bg_color(msgbox, lv_color_hex(THEME_COLOR_DARK), LV_PART_MAIN);
    lv_obj_t* header = lv_msgbox_get_header(msgbox);
    if (header) {
        lv_obj_set_style_bg_color(header, lv_color_hex(THEME_COLOR_MEDIUM), LV_PART_MAIN);
    }
    lv_obj_set_style_border_color(msgbox, lv_color_hex(THEME_COLOR_LIGHT), LV_PART_MAIN);
    lv_obj_set_width(msgbox, DISPLAY_WIDTH - 20);

    // Clean up pointers when msgbox is deleted
    lv_obj_add_event_cb(msgbox, [](lv_event_t* e){
        if (lv_event_get_code(e) == LV_EVENT_DELETE) {
            auto* self = (Scr*) lv_event_get_user_data(e);
            if (!self) return;
            if (self->msgbox_backdrop) {
                lv_obj_del_async(self->msgbox_backdrop);
                self->msgbox_backdrop = nullptr;
            }
            self->msgbox = nullptr;
            self->msgbox_visible = false;
        }
    }, LV_EVENT_DELETE, this);

    msgbox_visible = true;
    lv_obj_move_foreground(msgbox);
    if (msgbox_backdrop) lv_obj_move_foreground(msgbox_backdrop);
}

void Scr::closeMsgBox()
{
    if (msgbox) lv_msgbox_close_async(msgbox);
}

void updatePressure(Scr *scr, lv_obj_t *obj, int index, bool isHeightSensorPercentage)
{
    if (scr->prevPressures[index] != currentPressures[index])
    {
        if (isHeightSensorPercentage)
        {
            lv_label_set_text_fmt(obj, "%u%%", currentPressures[index]);
        }
        else if (getunitsMode() == UNITS_MODE::PSI)
        {
            lv_label_set_text_fmt(obj, "%u PSI", currentPressures[index]);
        }
        else
        {
            float val = currentPressures[index] / 14.5038f;
            val = val * 100;
            int b = (int)val % 100;
            int a = ((int)val - b) / 100;
            lv_label_set_text_fmt(obj, "%i.%i Bar", a, b);
        }
        scr->prevPressures[index] = currentPressures[index];
    }
}

void Scr::updatePressureValues()
{
    if (this->showPressures)
    {
        bool hs = statusBittset & (1 << StatusPacketBittset::HEIGHT_SENSOR_MODE);
        updatePressure(this, this->ui_lblPressureFrontPassenger, WHEEL_FRONT_PASSENGER, hs);
        updatePressure(this, this->ui_lblPressureRearPassenger,  WHEEL_REAR_PASSENGER,  hs);
        updatePressure(this, this->ui_lblPressureFrontDriver,    WHEEL_FRONT_DRIVER,    hs);
        updatePressure(this, this->ui_lblPressureRearDriver,     WHEEL_REAR_DRIVER,     hs);
        updatePressure(this, this->ui_lblPressureTank,           _TANK_INDEX,           false);
    }
}

void Scr::loop()
{
    handleFunctionRunOnNextFrame();

    SimplePoint tp = {touchX(), touchY()};
    if (isJustPressed())  this->runTouchInput(tp, true);
    if (isJustReleased()) this->runTouchInput(tp, false);

    this->updatePressureValues();
    if (this->alert) this->alert->loop();
}
